/*
  Title:          Simple DMA Test
  
  
  Important:      More details about the design are captured in the kernel file and the top level readme.txt file.  At a minimum give readme.txt a look since I document how to use the example
   (Read)         and any limitations that you may need to be aware of.
  
  
  Tool Versions:  The design was created with the following design environment:

                    1) Quartus 23.1 (Design includes Nios V/g which was released in 23.1)
                    2) Questasim Intel edition (Installed with Quartus)
                    3) oneAPI 2023.1.0
                    4) Linux development host (Ubuntu 22.04 was used, this design *should* work on windows but build_software.sh does not)

  
  Description:    This design leverages a simple DMA oneAPI kernel that has had it's RTL generated and integrated into the Nios V test system that will be used to control the acclerator.
                  The DMA kernel has been configured to read from memory in memory location 0 (BL0) while writes to memory in memory location 1 (BL1).  To see where this is important view
                  the code that handles the second write to the source and destination pointer registers.

                  The CPU is configured to have a single peripheral space located at 0x0010_0000 and it is 1MB in size.  So if you want to connect a different kernel/IP make sure to place it
                  between data master address 0x0010_0000-0x001F_FFFF.  If you run out of room (doubtful but possible) go into the Nios V parameterization GUI and add a second peripheral region.
                  I think the way it works with Nios V is if you deference a pointer to either peripheral region it automatically bypasses the data cache.  I wanted to be backwards compatible
                  with Nios II so I reuse the old handy dandy IOWR_32DIRECT and IORD_32DIRECT macros to access the peripheral region instead (see commments about the 12-bit offset limitation).

                  Nios V is a 32-bit processor but oneAPIs types like pointers and 64-bit types need to be written in two 32-bit parts.  Luckily bypassing the Nios V data cache (D$) is
                  as simple as deferencing a pointer in the peripheral space (0x0010_0000-0x001F_FFFF).  This code should be backwards compatible with Nios II since I leveraged the
                  IOWR_32DIRECT and IORD_32DIRECT macros.  According to io.h there is a upper limiation of 12-bits of the offset field, so this code instead does the safe thing and
                  adds the offset to the base (first argument of macro) and hardcodes the offset field to 0 (second argument of macro).
                  

  Author:         JCJB
  Date:           5/23/2023


  Version:        0.1
  
  Version History:
  
    0.1:  Initial version of the design that has Nios V controlling a simple oneAPI DMA kernel that copies data from source to destination four bytes at a time.

*/


#include <stdio.h>
#include <stdlib.h>
#include <sys/alt_cache.h>                // This comes from the BSP and contains Nios V data cache flushing APIs
#include "io.h"                           // This comes from the BSP that was generated by software_build.h, it includes the macros used to access the control/status registers of peripherals
#include "system.h"                       // This comes from the BSP that was generated by software_build.h, it contains information like address map, IRQ mapping, etc...

// including the kernel register map directly from the kernel build directory
#include "../../../kernels/simple_dma/build/simple_dma.report.prj/register_map_offsets.hpp"



/* 
   In bytes, must be a mulitple of 4.  Keep it a small number to shorten the simulation time and do not exceed the 1MB memory size (remember this code is in there too).
   Once the DMA gets going this buffer will fly by fast so setting it too high mostly affects the memory initialization and the correctness check at the endonce the DMA gets
   going this buffer will fly by fast so setting it too high mostly affects the memory initialization and the correctness check at the end. 
*/
#define BUFFER_LENGTH 1024


// Error numbers
#define TEST_PASS          0
#define TEST_FAIL          1


/*
   write_kernel_arguments will accept the source, destination, and transfer length and write them into the kernel CSRs
   Leveraging the old Nios IORW/IORD_32DIRECT macros since those also work for Nios II.  Nios V limits the offset
   of these marcos to 12-bit so I am adding the offset to the base before ahead of time since the base address
   of the macro does not have the limitation.  Since the kernel is located in the I/O space of the Nios V processor,
   you can simply dereference a pointer to bypass the data cache but that doesn't port to Nios II directly so that
   has been avoided here
*/
void write_kernel_arguments (unsigned int * source, unsigned int * destination, unsigned int length)
{

  /* 
     DMA source (note:  Nios V/g is 32-bit so we have to write the source pointer 32 bits at a time.  
     The source pointer needs to be case to unsigned int since the Nios macros are not expecting a pointer. 
  */
  IOWR_32DIRECT(SIMPLE_DMA_ACCELERATOR_BASE + ZTS9SIMPLEDMA_REGISTER_MAP_ARG_ARG_SOURCE_REG, 0, (unsigned int)source);
  IOWR_32DIRECT(SIMPLE_DMA_ACCELERATOR_BASE + ZTS9SIMPLEDMA_REGISTER_MAP_ARG_ARG_SOURCE_REG + 4, 0, 0);       // padding upper 32 bits to all zeros

  /* DMA destination (same thing applies to the destination as the source */
  IOWR_32DIRECT(SIMPLE_DMA_ACCELERATOR_BASE + ZTS9SIMPLEDMA_REGISTER_MAP_ARG_ARG_DESTINATION_REG, 0, (unsigned int)destination);
  IOWR_32DIRECT(SIMPLE_DMA_ACCELERATOR_BASE + ZTS9SIMPLEDMA_REGISTER_MAP_ARG_ARG_DESTINATION_REG + 4, 0, 0);  // padding upper 32 bits to all zeros
  
  /* DMA length */
  IOWR_32DIRECT(SIMPLE_DMA_ACCELERATOR_BASE + ZTS9SIMPLEDMA_REGISTER_MAP_ARG_ARG_LENGTH_REG, 0, BUFFER_LENGTH);         // Writing buffer length argument
  
  /* DMA start */
  IOWR_32DIRECT(SIMPLE_DMA_ACCELERATOR_BASE + ZTS9SIMPLEDMA_REGISTER_MAP_START_REG, 0, 1);                              // Writing 0x1 to the start bit

  // The DMA kernel should immediately start at this point
}




/*
  test() will populate a source buffer with an incrementing pattern of 'BUFFER_LENGTH' bytes, clear out the destination, instruct the DMA kernel to perform the source --> destination
  transfer, and checks that the destination contents match the source
*/
int test()
{
  // allocating source and destination buffers at compile time so that if too large a value is set for BUFFER_LENGTH then we'll find out early at compile time
  unsigned int source[BUFFER_LENGTH/4];
  unsigned int destination[BUFFER_LENGTH/4];
  int i;


  // initialize the source buffer with an incrementing pattern and clear out the destination before the accelerator clobbers it
  for (i = 0; i < (BUFFER_LENGTH/4); i++)
  {
    source[i] = i;
    destination[i] = 0;
  }


  // main memory (code_data_ram) is *not* in a peripheral region so all those writes to the source and destination need to be flushed from the data cache to avoid cache coherency issues when the accelerator attempts to access memory
  alt_dcache_flush(source, BUFFER_LENGTH);       // make sure all that source data that was set gets flushed out to main memory
  alt_dcache_flush(destination, BUFFER_LENGTH);  // make sure all that destination data that was zeroed out gets flushed out to main memory


  //  Start the DMA kernel
  write_kernel_arguments (source, destination, BUFFER_LENGTH);


  // spin waiting for the accelerator to complete (kernel will fire off interrupt as well but there is no register as of 2023.1.0 to clear it)
  while ((IORD_32DIRECT(SIMPLE_DMA_ACCELERATOR_BASE + ZTS9SIMPLEDMA_REGISTER_MAP_STATUS_REG, 0) & KERNEL_REGISTER_MAP_DONE_MASK) != KERNEL_REGISTER_MAP_DONE_MASK) {}

  
  /* 
    Now that the accelerator is done this code can start testing the destination buffer for correctness. Since the destination buffer was already flushed from the data cache, software can safely read the destination without
    additional data flushes.  Since the source was previously flushed as well it'll get fetched from main memory and warm up the D$ just like the destination buffer in the correctness loop.
  */
  
  // test the results at the destination buffer, if a failure is detected set pass to 0 and stop testing
  for (i = 0; i < (BUFFER_LENGTH/4); i++)
  {
    if (source[i] != destination[i])
    {
      printf("Test Fail:  Source address = 0x%x, Destination address = 0x%x, byte offset 0x%x.  Read value 0x%x instead of expected value 0x%x.\n", (unsigned int)source, (unsigned int)destination, (i*4), destination[i], source[i]);
      return TEST_FAIL;
    }  
  }

  // If we reach this point then all the data must have passed so we can issue a blanket statement that the entire test passed
  printf("Test Pass:  All the data at the destination matches the source.\n");

  return TEST_PASS; 
}


/*
    main() will return 0 on a test pass and non-zero on failures, see error numbers near top of this file.
*/
int main ()
{
  int return_val;
  
  printf("Test design for the simple DMA kernel\n\n");
  printf("Test will initialize %d incrementing four byte unsigned integers, have the accelerator DMA copy the data to a destination and then check the destination for correctness.\n", (BUFFER_LENGTH/4));
  
  return_val = test();
  printf("Software will now exit.\n");
  return return_val;
}

